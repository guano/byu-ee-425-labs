        CPU     8086
        ORG     0h
InterruptVectorTable:
        ; Internal x86 Interrupts:
        dd      0 ; Reserved (Div err)  ; Int 00h
        dd      0 ; Reserved (Step)     ; Int 01h
        dd      0 ; Reserved (NMI)      ; Int 02h
        dd      0 ; Reserved (Break)    ; Int 03h
        dd      0 ; Reserved (Overflow) ; Int 04h
        dd      0                       ; Int 05h
        dd      0                       ; Int 06h
        dd      0                       ; Int 07h
        ; Hardware Interrupts:
        dd      isr_reset ; Reset               ; Int 08h (IRQ 0)
        dd      isr_tick ; Tick                ; Int 09h (IRQ 1)
        dd      isr_keypress ; Keyboard            ; Int 0Ah (IRQ 2)
        dd      isr_game_over ; Simptris Game Over  ; Int 0Bh (IRQ 3)
        dd      isr_new_piece ; Simptris New Piece  ; Int 0Ch (IRQ 4)
        dd      isr_received ; Simptris Received   ; Int 0Dh (IRQ 5)
        dd      isr_touchdown ; Simptris Touchdown  ; Int 0Eh (IRQ 6)
        dd      isr_clear ; Simptris Clear      ; Int 0Fh (IRQ 7)
        ; Software Interrupts:
        dd      0 ; Reserved (PC BIOS)  ; Int 10h
        dd      0                       ; Int 11h
        dd      0                       ; Int 12h
        dd      0                       ; Int 13h
        dd      0                       ; Int 14h
        dd      0                       ; Int 15h
        dd      0                       ; Int 16h
        dd      0                       ; Int 17h
        dd      0                       ; Int 18h
        dd      0                       ; Int 19h
        dd      0                       ; Int 1Ah
        dd      0                       ; Int 1Bh
        dd      0                       ; Int 1Ch
        dd      0                       ; Int 1Dh
        dd      0                       ; Int 1Eh
        dd      0                       ; Int 1Fh
        dd      0                       ; Int 20h
        dd      0 ; Reserved (DOS)      ; Int 21h
        dd      0 ; Simptris Services   ; Int 22h
        dd      0                       ; Int 23h
        dd      0                       ; Int 24h
        dd      0                       ; Int 25h
        dd      0                       ; Int 26h
        dd      0                       ; Int 27h
        dd      0                       ; Int 28h
        dd      0                       ; Int 29h
        dd      0                       ; Int 2Ah
        dd      0                       ; Int 2Bh
        dd      0                       ; Int 2Ch
        dd      0                       ; Int 2Dh
        dd      0                       ; Int 2Eh
        dd      0                       ; Int 2Fh
KeyBuffer:                              ; Address 0xC0
        dw      0
NewPieceType:                           ; Address 0xC2
        dw      0
NewPieceID:                             ; Address 0xC4
        dw      0
NewPieceOrientation:                    ; Address 0xC6
        dw      0
NewPieceColumn:                         ; Address 0xC8
        dw      0
TouchdownID:                            ; Address 0xCA
	dw	0
ScreenBitMap0:                          ; Address 0xCC
        dw      0
ScreenBitMap1:
        dw      0
ScreenBitMap2:
        dw      0
ScreenBitMap3:
        dw      0
ScreenBitMap4:
        dw      0
ScreenBitMap5:
        dw      0
TIMES   100h-($-$$) db  0               ; Fill up to (but not including) address 100h with 0
	jmp	main
; This file contains support routines for 32-bit on the 8086.
; It is intended for use code generated by the C86 compiler.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SR_asldiv:			; l1 /= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_ldiv
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmod:			; l1 %= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmod
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmul:			; l1 *= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmul
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshl:			; l1 <<= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshl
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshr:			; l1 >>= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshr
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


SR_asuldiv:			; u1 /= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_uldiv
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asilmod:			; u1 %= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ilmod
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulmul:			; u1 *= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulmul
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshl:			; u1 << u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshl
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshr:			; u1 >> u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshr
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


; Main 32-bit routines begin here:

SR_ldiv:	; N_LDIV@
	pop    cx
	push   cs
	push   cx
	; LDIV@
	xor    cx,cx
	jmp    LSR_01
SR_uldiv:	; N_LUDIV@
	pop    cx
	push   cs
	push   cx
	; F_LUDIV@
	mov    cx,0001
	jmp    LSR_01
SR_lmod:	; N_LMOD@
	pop    cx
	push   cs
	push   cx
	; F_LMOD@
	mov    cx,0002
	jmp    LSR_01
SR_ilmod:	; N_LUMOD@
	pop    cx
	push   cs
	push   cx
	; LUMOD@
	mov    cx,0003
LSR_01:
	push   bp
	push   si
	push   di
	mov    bp,sp
	mov    di,cx
	mov    ax,[bp+0Ah]
	mov    dx,[bp+0Ch]
	mov    bx,[bp+0Eh]
	mov    cx,[bp+10h]
	or     cx,cx
	jne    LSR_02
	or     dx,dx
	je     LSR_10
	or     bx,bx
	je     LSR_10
LSR_02:
	test   di,0001
	jne    LSR_04
	or     dx,dx
	jns    LSR_03
	neg    dx
	neg    ax
	sbb    dx,0000
	or     di,000Ch
LSR_03:
	or     cx,cx
	jns    LSR_04
	neg    cx
	neg    bx
	sbb    cx,0000
	xor    di,0004
LSR_04:
	mov    bp,cx
	mov    cx,0020h
	push   di
	xor    di,di
	xor    si,si
LSR_05:
	shl    ax,1
	rcl    dx,1
	rcl    si,1
	rcl    di,1
	cmp    di,bp
	jb     LSR_07
	ja     LSR_06
	cmp    si,bx
	jb     LSR_07
LSR_06:
	sub    si,bx
	sbb    di,bp
	inc    ax
LSR_07:
	loop   LSR_05
	pop    bx
	test   bx,0002
	je     LSR_08
	mov    ax,si
	mov    dx,di
	shr    bx,1
LSR_08:
	test   bx,0004h
	je     LSR_09
	neg    dx
	neg    ax
	sbb    dx,0000
LSR_09:
	pop    di
	pop    si
	pop    bp
	retf   0008
LSR_10:
	div    bx
	test   di,0002
	je     LSR_11
	xchg   dx,ax
LSR_11:
	xor    dx,dx
	jmp    LSR_09
SR_lshl:	; N_LXLSH@
SR_ulshl:
	; r = a << b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

	mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXLSH@
	cmp    cl,10h
	jnb    LSR_12
	mov    bx,ax
	shl    ax,cl
	shl    dx,cl
	neg    cl
	add    cl,10h
	shr    bx,cl
	or     dx,bx
	pop    cx
	pop    bp
	retf
LSR_12:
	sub    cl,10h
	xchg   dx,ax
	xor    ax,ax
	shl    dx,cl
	pop    cx
	pop    bp
	retf
SR_lshr:	; N_LXRSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXRSH@
	cmp    cl,10h
	jnb    LSR_13
	mov    bx,dx
	shr    ax,cl
	sar    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_13:
	sub    cl,10h
	xchg   dx,ax
	cwd
	sar    ax,cl
	pop    cx
	pop    bp
	retf
SR_ulshr:	; N_LXURSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXURSH@
	cmp    cl,10h
	jnb    LSR_14
	mov    bx,dx
	shr    ax,cl
	shr    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_14:
	sub    cl,10h
	xchg   dx,ax
	xor    dx,dx
	shr    ax,cl
	pop    cx
	pop    bp
	retf
SR_lmul:	; N_LXMUL@
SR_ulmul:
	; r = a * b
	push   bp
	push   si
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx
	push   bx

        mov    bx, [bp+6]	; pop loword(a)
	mov    cx, [bp+8]	; pop hiword(a)
	mov    ax, [bp+10]	; pop loword(b)
	mov    dx, [bp+12]	; pop hiword(b)
	
	xchg   si,ax
	xchg   dx,ax
	test   ax,ax
	je     LSR_15
	mul    bx
LSR_15:
	jcxz   LSR_16
	xchg   cx,ax
	mul    si
	add    ax,cx
LSR_16:
	xchg   si,ax
	mul    bx
	add    dx,si
	pop    bx
	pop    cx
	pop    si
	pop    bp
	ret

; Generated by c86 (BYU-NASM) 5.1 (beta) from clib.c
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
new_line:
	db	13,10,36
	ALIGN	2
signalEOI:
	jmp	L_clib_1
L_clib_2:
	mov	al, 0x20
	out	0x20, al
	mov	sp, bp
	pop	bp
	ret
L_clib_1:
	push	bp
	mov	bp, sp
	jmp	L_clib_2
	ALIGN	2
exit:
	jmp	L_clib_4
L_clib_5:
	mov	ah, 4Ch
	mov	al, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_4:
	push	bp
	mov	bp, sp
	jmp	L_clib_5
	ALIGN	2
print:
	jmp	L_clib_7
L_clib_8:
	mov	ah, 40h
	mov	bx, 1
	mov	cx, [bp+6]
	mov	dx, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_7:
	push	bp
	mov	bp, sp
	jmp	L_clib_8
	ALIGN	2
printChar:
	jmp	L_clib_10
L_clib_11:
	mov	ah, 2
	mov	dl, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_10:
	push	bp
	mov	bp, sp
	jmp	L_clib_11
	ALIGN	2
printNewLine:
	jmp	L_clib_13
L_clib_14:
	mov	ah, 9
	mov	dx, new_line
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_13:
	push	bp
	mov	bp, sp
	jmp	L_clib_14
	ALIGN	2
printString:
	jmp	L_clib_16
L_clib_17:
	xor	si,si
	mov	bx, [bp+4]
	jmp	printString2
	printString1:
	inc	si
	printString2:
	cmp	byte [bx+si],0
	jne	printString1
	mov	dx, bx
	mov	cx, si
	mov	ah, 40h
	mov	bx, 1
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_16:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_clib_17
	ALIGN	2
printInt:
	jmp	L_clib_19
L_clib_20:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	cmp	word [bp+4], 0
	jge	L_clib_21
	mov	byte [bp-10], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	neg	ax
	mov	word [bp+4], ax
L_clib_21:
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_22
	mov	word [bp-4], 1
	jmp	L_clib_23
L_clib_22:
	jmp	L_clib_25
L_clib_24:
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
L_clib_25:
	mov	ax, word [bp+4]
	cwd
	idiv	word [bp-4]
	test	ax, ax
	je	L_clib_24
L_clib_26:
L_clib_23:
	jmp	L_clib_28
L_clib_27:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	ax, dx
	mov	word [bp+4], ax
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
	mov	ax, word [bp-4]
	mov	word [bp-4], ax
L_clib_28:
	cmp	word [bp-4], 0
	jg	L_clib_27
L_clib_29:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_19:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_20
	ALIGN	2
printLong:
	jmp	L_clib_31
L_clib_32:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	cmp	word [bp+6], 0
	jg	L_clib_33
	jl	L_clib_34
	cmp	word [bp+4], 0
	jae	L_clib_33
L_clib_34:
	mov	byte [bp-17], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	word [bp+4], ax
	mov	word [bp+6], dx
L_clib_33:
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_35
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_36
L_clib_35:
	jmp	L_clib_38
L_clib_37:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_38:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_ldiv
	or	dx, ax
	je	L_clib_37
L_clib_39:
L_clib_36:
	jmp	L_clib_41
L_clib_40:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_lmod
	mov	word [bp+4], ax
	mov	word [bp+6], dx
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_41:
	cmp	word [bp-4], 0
	jg	L_clib_40
	jne	L_clib_43
	cmp	word [bp-6], 0
	ja	L_clib_40
L_clib_43:
L_clib_42:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_31:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_32
	ALIGN	2
printUInt:
	jmp	L_clib_45
L_clib_46:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_47
	mov	word [bp-4], 1
	jmp	L_clib_48
L_clib_47:
	jmp	L_clib_50
L_clib_49:
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_50:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	test	ax, ax
	je	L_clib_49
L_clib_51:
L_clib_48:
	jmp	L_clib_53
L_clib_52:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	word [bp+4], dx
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_53:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_clib_52
L_clib_54:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_45:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_46
	ALIGN	2
printULong:
	jmp	L_clib_56
L_clib_57:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_58
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_59
L_clib_58:
	jmp	L_clib_61
L_clib_60:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_61:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	or	dx, ax
	je	L_clib_60
L_clib_62:
L_clib_59:
	jmp	L_clib_64
L_clib_63:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	lea	ax, [bp+4]
	push	ax
	call	SR_asilmod
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_64:
	mov	ax, word [bp-6]
	mov	dx, word [bp-4]
	or	dx, ax
	jne	L_clib_63
L_clib_65:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_56:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_57
	ALIGN	2
printByte:
	jmp	L_clib_67
L_clib_68:
	mov	al, byte [bp+4]
	cbw
	mov	cx, 4
	sar	ax, cl
	and	ax, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_69
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_70
L_clib_69:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_70:
	mov	byte [bp-3], al
	mov	al, byte [bp+4]
	and	al, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_71
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_72
L_clib_71:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_72:
	mov	byte [bp-2], al
	mov	ax, 2
	push	ax
	lea	ax, [bp-3]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_67:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_clib_68
	ALIGN	2
printWord:
	jmp	L_clib_74
L_clib_75:
	mov	word [bp-2], 3
	jmp	L_clib_77
L_clib_76:
	mov	ax, word [bp+4]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_80
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_81
L_clib_80:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_81:
	mov	si, word [bp-2]
	lea	dx, [bp-7]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp+4]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp+4], ax
L_clib_79:
	dec	word [bp-2]
L_clib_77:
	cmp	word [bp-2], 0
	jge	L_clib_76
L_clib_78:
	mov	ax, 4
	push	ax
	lea	ax, [bp-7]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_74:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_clib_75
	ALIGN	2
printDWord:
	jmp	L_clib_83
L_clib_84:
	lea	ax, [bp+4]
	mov	si, ax
	mov	ax, word [si]
	mov	word [bp-6], ax
	lea	ax, [bp+4]
	mov	si, ax
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-8], ax
	mov	word [bp-2], 3
	jmp	L_clib_86
L_clib_85:
	mov	ax, word [bp-6]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_89
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_90
L_clib_89:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_90:
	mov	dx, word [bp-2]
	add	dx, 4
	mov	si, dx
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-6]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_91
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_92
L_clib_91:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_92:
	mov	si, word [bp-2]
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-8]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-8], ax
L_clib_88:
	dec	word [bp-2]
L_clib_86:
	cmp	word [bp-2], 0
	jge	L_clib_85
L_clib_87:
	mov	ax, 8
	push	ax
	lea	ax, [bp-16]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_83:
	push	bp
	mov	bp, sp
	sub	sp, 16
	jmp	L_clib_84

	align	2
SlidePiece:	; void SlidePiece(int ID, int direction)
	push	bp
	mov	bp, sp
	push	ax
	push	dx
 	mov	ah, 0		; Slide piece operation
  	mov	al, [bp+6]	; Move direction (loword only)
	mov	dx, [bp+4]	; Move id
	int	1Bh		; Call Simptris services
	pop	dx
	pop	ax
	pop	bp
	ret
RotatePiece:	; void RotatePiece(int ID, int direction)
	push	bp
	mov	bp, sp
	push	ax
	push	dx
 	mov	ah, 1		; Rotate piece operation
 	mov	al, [bp+6]	; Move direction (loword only)
	mov	dx, [bp+4]	; Move id
	int	1Bh		; Call Simptris services
	pop	dx
	pop	ax
	pop	bp
	ret
SeedSimptris:	; void SeedSimptris(long seed)
	push	bp
	mov	bp, sp
	push	ax
	push	cx
	push    dx
 	mov	ah, 2		; Seed operation
	mov	dx, [bp+4]	; Move loword of seed
	mov	cx, [bp+6]	; Move hiword of seed
	int	1Bh		; Call Simptris services
	pop	dx
	pop	cx
	pop	ax
	pop	bp
	ret
StartSimptris:	; void StartSimptris(void)
	push	ax
 	mov	ah, 3		; Start Simptris operation
	int	1Bh		; Call Simptris services
	pop	ax
	ret


; 1    Save the context of whatever was running by pushing all registers onto the stack, except SP, SS, CS, IP, and the flags.
; 2    Enable interrupts to allow higher priority IRQs to interrupt.
; 3    Run the interrupt handler, which is usually a C function that does the work for this interrupt.
; 4    Disable interrupts.
; 5    Send the EOI command to the PIC, informing it that the handler is finished.
; 6    Restore the context of what was running before the interrupt occurred by popping the registers saved in step 1 off the stack.
; 7    Execute the iret instruction. This restores in one atomic operation the values for IP, CS, and the flags, which were automatically saved on the stack by the processor when the interrupt occurred. This effectively restores execution to the point where the interrupt occurred.




isr_reset:
	; save context
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es
	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_reset_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_reset_not_lowest_interrupt:

	call YKEnterISR
	; enable interrupts for higher priority IRQ
	sti	

	; run interrupt handler
	
	; disable interrupts
	; sent EOI to PIC
	; restore context

	; But we don't have to do any of that, because we ARE the highest-priority interrupt
	; And it will end the program. So no saving context, no enabling interrupts, 
	; and no restoring context.
	call c_isr_reset
	

	cli
	
	mov	al, 0x20
	out 	0x20, al

		
	call YKExitISR
	
	pop es
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax	
	
	iret	; This should not even happen.



isr_keypress:
		; Save context
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es

	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_keypress_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_keypress_not_lowest_interrupt:

	call YKEnterISR

		; Enable interrupts for higher-priority 
	sti

		; Run interrupt handler
	call c_isr_keypress


		; disable interrupts
	cli

		;send EOI to PIC
	mov	al, 0x20	; Load nonspecific EOI value (0x20) into register al
	out	0x20, al	; Write EOI to PIC (port 0x20)

	
	call YKExitISR
		; Restore context
	pop es
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax	
		; Execute IRET
	iret



isr_tick:
		; Save context
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es
	
	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_tick_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_tick_not_lowest_interrupt:

	call YKEnterISR

		; Enable interrupts for higher-priority 
	sti

		; Run interrupt handler
	call c_isr_tick
		; disable interrupts
	cli

		;send EOI to PIC
	mov	al, 0x20	; Load nonspecific EOI value (0x20) into register al
	out	0x20, al	; Write EOI to PIC (port 0x20)

		
	call YKExitISR
		; Restore context
	pop es
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax

	   ; Execute IRET
	iret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;	NEW SIMPTRIS ISRS below		;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				 ;
;	GAME OVER ISR		 ;
;				 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isr_game_over:
	; save context
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es
	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_game_over_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_game_over_not_lowest_interrupt:

	call YKEnterISR

	sti ;enable interrupts to allow higher priority IRQs to interrupt

	call c_isr_game_over ; (Indicate game over. No new pieces appear)

	cli ; disable interrupts

	mov	al, 0x20 ;Send EOI command to PIC, informing it that handler is finished
	out	0x20, al

	call YKExitISR

	pop es	; restores context of what was running b4 interrupt occured
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax

	iret ; restores values for IP, CS, flags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;
;	     NEW PIECE ISR		;
;					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isr_new_piece:
	push ax ; save context
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es

	call YKEnterISR
	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_new_piece_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_new_piece_not_lowest_interrupt:

	sti ;enable interrupts to allow higher priority IRQs to interrupt

	call c_isr_new_piece ; (Indicate that a new piece has appeared on board...)

	cli ; disable interrupts

	mov	al, 0x20 ;Send EOI command to PIC, informing it that handler is finished
	out	0x20, al

	call YKExitISR

	pop es	; restores context of what was running b4 interrupt occured
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax

	iret ; restores values for IP, CS, flags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;
;	    RECEIVED ISR		;
;					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isr_received:
	push ax ; save context
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	push ds
	push es
	; Here we test to see if we are the lowest-level interrupt.
	; If we are, we need to save the task's stack that we interrupted
	mov ax, [YKISRCallDepth]
	test ax, ax
	jnz isr_received_not_lowest_interrupt

	; Save the SP of the task we interrupted
	mov bx, [YKRdyList]
	mov [bx], sp

isr_received_not_lowest_interrupt:

	call YKEnterISR

	sti ;enable interrupts to allow higher priority IRQs to interrupt

	call c_isr_new_piece ; (Indicate that a new piece has appeared on board...)

	cli ; disable interrupts
	
	mov	al, 0x20	; Load nonspecific EOI value (0x20) into register al
	out	0x20, al	; Write EOI to PIC (port 0x20)

	call YKExitISR

	pop es	; restores context of what was running b4 interrupt occured
	pop ds
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax

	iret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;
;	     TOUCHDOWN ISR		;
;					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isr_touchdown:

	mov	al, 0x20	; Load nonspecific EOI value (0x20) into register al
	out	0x20, al	; Write EOI to PIC (port 0x20)

	iret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;
;	       CLEAR ISR		;
;					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

isr_clear:

	mov	al, 0x20	; Load nonspecific EOI value (0x20) into register al
	out	0x20, al	; Write EOI to PIC (port 0x20)

	iret



; Generated by c86 (BYU-NASM) 5.1 (beta) from myinth.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
c_isr_reset:
	jmp	L_myinth_1
L_myinth_2:
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_myinth_1:
	push	bp
	mov	bp, sp
	jmp	L_myinth_2
	ALIGN	2
c_isr_tick:
	jmp	L_myinth_4
L_myinth_5:
	call	YKTickHandler
	mov	sp, bp
	pop	bp
	ret
L_myinth_4:
	push	bp
	mov	bp, sp
	jmp	L_myinth_5
L_myinth_8:
	DB	") IGNORED",0xA,0
L_myinth_7:
	DB	0xA,"KEYPRESS (",0
	ALIGN	2
c_isr_keypress:
	jmp	L_myinth_9
L_myinth_10:
	mov	al, byte [KeyBuffer]
	mov	byte [bp-1], al
	mov	ax, 11
	push	ax
	mov	ax, L_myinth_7
	push	ax
	call	print
	add	sp, 4
	push	word [bp-1]
	call	printChar
	add	sp, 2
	mov	ax, 10
	push	ax
	mov	ax, L_myinth_8
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_myinth_9:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_myinth_10
L_myinth_12:
	DB	0xA,"GAME OVER",0xA,0
	ALIGN	2
c_isr_game_over:
	jmp	L_myinth_13
L_myinth_14:
	mov	ax, L_myinth_12
	push	ax
	call	printString
	add	sp, 2
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_myinth_13:
	push	bp
	mov	bp, sp
	jmp	L_myinth_14
	ALIGN	2
L_myinth_16:
	DW	0
L_myinth_17:
	DB	0xA,"*****new piece appeared on board*****",0xA,0
	ALIGN	2
c_isr_new_piece:
	jmp	L_myinth_18
L_myinth_19:
	mov	ax, word [NewPieceType]
	mov	word [bp-2], ax
	mov	ax, word [NewPieceOrientation]
	mov	word [bp-4], ax
	mov	ax, word [NewPieceID]
	mov	word [bp-6], ax
	mov	ax, word [NewPieceColumn]
	mov	word [bp-8], ax
	mov	ax, L_myinth_17
	push	ax
	call	printString
	add	sp, 2
	mov	ax, word [L_myinth_16]
	mov	cx, 3
	shl	ax, cl
	mov	si, ax
	add	si, newPieceArray
	mov	ax, word [bp-6]
	mov	word [si], ax
	mov	ax, word [L_myinth_16]
	mov	cx, 3
	shl	ax, cl
	add	ax, newPieceArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp-2]
	mov	word [si], ax
	mov	ax, word [L_myinth_16]
	mov	cx, 3
	shl	ax, cl
	add	ax, newPieceArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	ax, word [L_myinth_16]
	mov	cx, 3
	shl	ax, cl
	add	ax, newPieceArray
	mov	si, ax
	add	si, 6
	mov	ax, word [bp-8]
	mov	word [si], ax
	mov	ax, word [L_myinth_16]
	mov	cx, 3
	shl	ax, cl
	add	ax, newPieceArray
	push	ax
	push	word [newPieceQueuePTR]
	call	YKQPost
	add	sp, 4
	mov	ax, word [L_myinth_16]
	inc	ax
	mov	word [L_myinth_16], ax
	cmp	word [L_myinth_16], 20
	jne	L_myinth_20
	mov	word [L_myinth_16], 0
L_myinth_20:
	mov	sp, bp
	pop	bp
	ret
L_myinth_18:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_myinth_19
	ALIGN	2
c_isr_received:
	jmp	L_myinth_22
L_myinth_23:
	mov	ax, 1
	push	ax
	push	word [pieceMoveEvent]
	call	YKEventSet
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_myinth_22:
	push	bp
	mov	bp, sp
	jmp	L_myinth_23
; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
started_running:
	DB	0
	ALIGN	2
YKInitialize:
	jmp	L_yakc_1
L_yakc_2:
	mov	word [YKCtxSwCount], 0
	mov	word [YKIdleCount], 0
	mov	word [YKCurrentlyExecuting], 0
	mov	word [YKISRCallDepth], 0
	call	YKEnterMutex
	mov	word [YKAvailTCBList], YKTCBArray
	mov	word [bp-2], 0
	jmp	L_yakc_4
L_yakc_3:
	mov	ax, word [bp-2]
	inc	ax
	mov	cx, 24
	imul	cx
	add	ax, YKTCBArray
	push	ax
	mov	ax, word [bp-2]
	mov	cx, 24
	imul	cx
	mov	dx, ax
	add	dx, YKTCBArray
	mov	si, dx
	add	si, 10
	pop	ax
	mov	word [si], ax
L_yakc_6:
	inc	word [bp-2]
L_yakc_4:
	cmp	word [bp-2], 9
	jl	L_yakc_3
L_yakc_5:
	mov	word [(226+YKTCBArray)], 0
	mov	word [bp-2], 0
	jmp	L_yakc_8
L_yakc_7:
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKSEMArray
	mov	si, ax
	add	si, 2
	mov	word [si], 0
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	mov	si, ax
	add	si, YKSEMArray
	mov	word [si], -10
L_yakc_10:
	inc	word [bp-2]
L_yakc_8:
	cmp	word [bp-2], 19
	jl	L_yakc_7
L_yakc_9:
	mov	word [bp-2], 0
	jmp	L_yakc_12
L_yakc_11:
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQueueArray
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 2
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 6
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 8
	mov	word [si], 0
L_yakc_14:
	inc	word [bp-2]
L_yakc_12:
	cmp	word [bp-2], 2
	jl	L_yakc_11
L_yakc_13:
	mov	al, 100
	push	ax
	mov	ax, (idleStack+512)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_2
	ALIGN	2
YKIdleTask:
	jmp	L_yakc_16
L_yakc_17:
	jmp	L_yakc_19
L_yakc_18:
	call	YKEnterMutex
	mov	ax, word [YKIdleCount]
	inc	ax
	mov	word [YKIdleCount], ax
	call	YKExitMutex
L_yakc_19:
	jmp	L_yakc_18
L_yakc_20:
	mov	sp, bp
	pop	bp
	ret
L_yakc_16:
	push	bp
	mov	bp, sp
	jmp	L_yakc_17
	ALIGN	2
YKNewTask:
	jmp	L_yakc_22
L_yakc_23:
	mov	ax, word [bp+6]
	sub	ax, 2
	mov	word [bp+6], ax
	mov	ax, word [YKAvailTCBList]
	mov	word [bp-2], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKAvailTCBList], ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	mov	al, byte [bp+8]
	xor	ah, ah
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	call	YKEnterMutex
	mov	ax, word [YKRdyList]
	test	ax, ax
	jne	L_yakc_24
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	jmp	L_yakc_25
L_yakc_24:
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	jmp	L_yakc_27
L_yakc_26:
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_27:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-2]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_26
L_yakc_28:
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_29
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	jmp	L_yakc_30
L_yakc_29:
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_30:
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_25:
	mov	si, word [bp-2]
	mov	ax, word [bp+6]
	mov	word [si], ax
	mov	si, word [bp-2]
	add	si, 2
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	ax, word [si]
	sub	ax, 22
	mov	word [si], ax
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 22
	mov	word [si], 512
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 20
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 18
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 16
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 14
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 10
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 8
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 6
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 4
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 2
	mov	word [si], 0
	mov	si, word [bp-2]
	mov	si, word [si]
	mov	word [si], 0
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_yakc_22:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_23
L_yakc_32:
	DB	"run called. Calling the scheduler",0xA,0
	ALIGN	2
YKRun:
	jmp	L_yakc_33
L_yakc_34:
	mov	ax, L_yakc_32
	push	ax
	call	printString
	add	sp, 2
	mov	byte [started_running], 1
	xor	ax, ax
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_yakc_33:
	push	bp
	mov	bp, sp
	jmp	L_yakc_34
	ALIGN	2
YKScheduler:
	jmp	L_yakc_36
L_yakc_37:
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	mov	ax, word [YKCurrentlyExecuting]
	mov	word [bp-4], ax
	mov	al, byte [started_running]
	test	al, al
	je	L_yakc_39
L_yakc_38:
	mov	ax, word [bp-2]
	cmp	ax, word [YKCurrentlyExecuting]
	je	L_yakc_39
L_yakc_40:
	mov	ax, word [YKCtxSwCount]
	inc	ax
	mov	word [YKCtxSwCount], ax
	mov	ax, word [bp-2]
	mov	word [YKCurrentlyExecuting], ax
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_yakc_41
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	xor	ax, ax
	push	ax
	call	YKDispatcher_save_context
	add	sp, 10
	jmp	L_yakc_42
L_yakc_41:
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	mov	ax, word [bp-4]
	add	ax, 2
	push	ax
	push	word [bp-4]
	push	word [bp+4]
	call	YKDispatcher_save_context
	add	sp, 10
L_yakc_42:
L_yakc_39:
	mov	sp, bp
	pop	bp
	ret
L_yakc_36:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_37
	ALIGN	2
YKDelayTask:
	jmp	L_yakc_44
L_yakc_45:
	call	YKEnterMutex
	mov	ax, word [bp+4]
	test	ax, ax
	je	L_yakc_46
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKRdyList], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [YKSuspList]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	word [YKSuspList], ax
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_47
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_47:
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [bp+4]
	mov	word [si], ax
	jmp	L_yakc_48
L_yakc_46:
	call	YKExitMutex
	jmp	L_yakc_49
L_yakc_48:
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	call	YKExitMutex
L_yakc_49:
	mov	sp, bp
	pop	bp
	ret
L_yakc_44:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_45
	ALIGN	2
YKTickHandler:
	jmp	L_yakc_51
L_yakc_52:
	mov	ax, word [YKSuspList]
	mov	word [bp-2], ax
	call	YKEnterMutex
	mov	ax, word [YKTickNum]
	inc	ax
	mov	word [YKTickNum], ax
	jmp	L_yakc_54
L_yakc_53:
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-6], ax
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	dec	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_56
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_57
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKSuspList], ax
	jmp	L_yakc_58
L_yakc_57:
	mov	si, word [bp-2]
	add	si, 10
	mov	di, word [bp-2]
	add	di, 12
	mov	di, word [di]
	add	di, 10
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_58:
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_59
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 10
	mov	di, word [di]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_59:
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	jmp	L_yakc_61
L_yakc_60:
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_61:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-2]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_60
L_yakc_62:
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_63
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	jmp	L_yakc_64
L_yakc_63:
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_64:
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_56:
	mov	ax, word [bp-6]
	mov	word [bp-2], ax
L_yakc_54:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_53
L_yakc_55:
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_51:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_yakc_52
	ALIGN	2
YKEnterISR:
	jmp	L_yakc_66
L_yakc_67:
	mov	ax, word [YKISRCallDepth]
	inc	ax
	mov	word [YKISRCallDepth], ax
	mov	sp, bp
	pop	bp
	ret
L_yakc_66:
	push	bp
	mov	bp, sp
	jmp	L_yakc_67
	ALIGN	2
YKExitISR:
	jmp	L_yakc_69
L_yakc_70:
	mov	ax, word [YKISRCallDepth]
	dec	ax
	mov	word [YKISRCallDepth], ax
	test	ax, ax
	jne	L_yakc_71
	xor	ax, ax
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_71:
	mov	sp, bp
	pop	bp
	ret
L_yakc_69:
	push	bp
	mov	bp, sp
	jmp	L_yakc_70
	ALIGN	2
YKEventCreate:
	jmp	L_yakc_73
L_yakc_74:
	call	YKEnterMutex
	mov	word [bp-2], 0
	jmp	L_yakc_76
L_yakc_75:
	inc	word [bp-2]
L_yakc_76:
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	mov	si, ax
	add	si, YKEVENTArray
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_75
L_yakc_77:
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKEVENTArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	mov	si, ax
	add	si, YKEVENTArray
	mov	word [si], 1
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKEVENTArray
L_yakc_78:
	mov	sp, bp
	pop	bp
	ret
L_yakc_73:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_74
	ALIGN	2
YKEventPend:
	jmp	L_yakc_80
L_yakc_81:
	call	YKEnterMutex
	mov	ax, word [bp+8]
	test	ax, ax
	jne	L_yakc_82
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	and	ax, word [bp+6]
	je	L_yakc_83
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-4], ax
	call	YKExitMutex
	mov	ax, word [bp-4]
	jmp	L_yakc_84
L_yakc_83:
	jmp	L_yakc_85
L_yakc_82:
	mov	ax, word [bp+6]
	cmp	ax, word [bp+6]
	je	L_yakc_87
	xor	ax, ax
	jmp	L_yakc_88
L_yakc_87:
	mov	ax, 1
L_yakc_88:
	mov	si, word [bp+4]
	add	si, 2
	and	ax, word [si]
	je	L_yakc_86
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-4], ax
	call	YKExitMutex
	mov	ax, word [bp-4]
	jmp	L_yakc_84
L_yakc_86:
L_yakc_85:
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKRdyList], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [YKEventBlockingList]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	word [YKEventBlockingList], ax
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_89
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_89:
	mov	si, word [bp-2]
	add	si, 18
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	si, word [bp-2]
	add	si, 20
	mov	ax, word [bp+6]
	mov	word [si], ax
	mov	si, word [bp-2]
	add	si, 22
	mov	ax, word [bp+8]
	mov	word [si], ax
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-4], ax
	call	YKExitMutex
	mov	ax, word [bp-4]
L_yakc_84:
	mov	sp, bp
	pop	bp
	ret
L_yakc_80:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_81
	ALIGN	2
YKEventSet:
	jmp	L_yakc_91
L_yakc_92:
	call	YKEnterMutex
	mov	ax, word [YKEventBlockingList]
	mov	word [bp-2], ax
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	or	ax, word [bp+6]
	mov	si, word [bp+4]
	add	si, 2
	mov	word [si], ax
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_93
	call	YKExitMutex
	jmp	L_yakc_94
L_yakc_93:
	jmp	L_yakc_96
L_yakc_95:
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-6], ax
	mov	si, word [bp-2]
	add	si, 18
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	je	L_yakc_98
	mov	ax, word [bp-6]
	mov	word [bp-2], ax
	jmp	L_yakc_96
L_yakc_98:
	mov	si, word [bp-2]
	add	si, 22
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_99
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	si, word [bp-2]
	add	si, 20
	and	ax, word [si]
	je	L_yakc_100
	mov	ax, word [bp-2]
	mov	word [bp-8], ax
	jmp	L_yakc_101
L_yakc_100:
	mov	word [bp-8], 0
L_yakc_101:
	jmp	L_yakc_102
L_yakc_99:
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	si, word [bp-2]
	add	si, 20
	and	ax, word [si]
	mov	si, word [bp-2]
	add	si, 20
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_103
	mov	ax, word [bp-2]
	mov	word [bp-8], ax
	jmp	L_yakc_104
L_yakc_103:
	mov	word [bp-8], 0
L_yakc_104:
L_yakc_102:
	mov	ax, word [bp-8]
	test	ax, ax
	je	L_yakc_105
	mov	si, word [bp-8]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_106
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKEventBlockingList], ax
	jmp	L_yakc_107
L_yakc_106:
	mov	si, word [bp-8]
	add	si, 10
	mov	di, word [bp-8]
	add	di, 12
	mov	di, word [di]
	add	di, 10
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_107:
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_108
	mov	si, word [bp-8]
	add	si, 12
	mov	di, word [bp-8]
	add	di, 10
	mov	di, word [di]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_108:
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	jmp	L_yakc_110
L_yakc_109:
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_110:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-8]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_109
L_yakc_111:
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_112
	mov	ax, word [bp-8]
	mov	word [YKRdyList], ax
	jmp	L_yakc_113
L_yakc_112:
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-8]
	mov	word [si], ax
L_yakc_113:
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-8]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-8]
	mov	word [si], ax
	mov	si, word [bp-8]
	add	si, 18
	mov	word [si], 0
L_yakc_105:
	mov	ax, word [bp-6]
	mov	word [bp-2], ax
L_yakc_96:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_95
L_yakc_97:
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_114
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_114:
	call	YKExitMutex
L_yakc_94:
	mov	sp, bp
	pop	bp
	ret
L_yakc_91:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_yakc_92
	ALIGN	2
YKEventReset:
	jmp	L_yakc_116
L_yakc_117:
	call	YKEnterMutex
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	mov	dx, word [bp+6]
	not	dx
	and	ax, dx
	mov	si, word [bp+4]
	add	si, 2
	mov	word [si], ax
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_116:
	push	bp
	mov	bp, sp
	jmp	L_yakc_117
	ALIGN	2
YKSemCreate:
	jmp	L_yakc_119
L_yakc_120:
	call	YKEnterMutex
	mov	word [bp-2], 0
	jmp	L_yakc_122
L_yakc_121:
	inc	word [bp-2]
L_yakc_122:
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKSEMArray
	mov	si, ax
	add	si, 2
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_121
L_yakc_123:
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	mov	si, ax
	add	si, YKSEMArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKSEMArray
	mov	si, ax
	add	si, 2
	mov	word [si], 1
	mov	ax, word [bp-2]
	shl	ax, 1
	shl	ax, 1
	add	ax, YKSEMArray
L_yakc_124:
	mov	sp, bp
	pop	bp
	ret
L_yakc_119:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_120
	ALIGN	2
YKSemPend:
	jmp	L_yakc_126
L_yakc_127:
	call	YKEnterMutex
	mov	si, word [bp+4]
	mov	ax, word [si]
	dec	ax
	mov	word [si], ax
	call	YKExitMutex
	mov	si, word [bp+4]
	cmp	word [si], 0
	jge	L_yakc_129
L_yakc_128:
	call	YKEnterMutex
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKRdyList], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [YKSemaphoreWaitingList]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	word [YKSemaphoreWaitingList], ax
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_130
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_130:
	mov	si, word [bp-2]
	add	si, 14
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	call	YKExitMutex
L_yakc_129:
	mov	sp, bp
	pop	bp
	ret
L_yakc_126:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_127
	ALIGN	2
YKSemPost:
	jmp	L_yakc_132
L_yakc_133:
	mov	word [bp-8], 0
	mov	ax, word [YKSemaphoreWaitingList]
	mov	word [bp-2], ax
	call	YKEnterMutex
	mov	si, word [bp+4]
	mov	ax, word [si]
	inc	ax
	mov	word [si], ax
	jmp	L_yakc_135
L_yakc_134:
	mov	si, word [bp-2]
	add	si, 14
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_137
	mov	ax, word [bp-8]
	test	ax, ax
	jne	L_yakc_138
	mov	ax, word [bp-2]
	mov	word [bp-8], ax
	jmp	L_yakc_139
L_yakc_138:
	mov	si, word [bp-2]
	add	si, 6
	mov	di, word [bp-8]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jle	L_yakc_140
	mov	ax, word [bp-2]
	mov	word [bp-8], ax
L_yakc_140:
L_yakc_139:
L_yakc_137:
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_135:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_134
L_yakc_136:
	mov	ax, word [bp-8]
	test	ax, ax
	jne	L_yakc_141
	call	YKExitMutex
	jmp	L_yakc_142
L_yakc_141:
	mov	si, word [bp-8]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_143
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKSemaphoreWaitingList], ax
	jmp	L_yakc_144
L_yakc_143:
	mov	si, word [bp-8]
	add	si, 10
	mov	di, word [bp-8]
	add	di, 12
	mov	di, word [di]
	add	di, 10
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_144:
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_145
	mov	si, word [bp-8]
	add	si, 12
	mov	di, word [bp-8]
	add	di, 10
	mov	di, word [di]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_145:
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	jmp	L_yakc_147
L_yakc_146:
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_147:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-8]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_146
L_yakc_148:
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_149
	mov	ax, word [bp-8]
	mov	word [YKRdyList], ax
	jmp	L_yakc_150
L_yakc_149:
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-8]
	mov	word [si], ax
L_yakc_150:
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-8]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	mov	si, word [bp-8]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-8]
	mov	word [si], ax
	mov	si, word [bp-8]
	add	si, 14
	mov	word [si], 0
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_151
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_151:
	call	YKExitMutex
L_yakc_142:
	mov	sp, bp
	pop	bp
	ret
L_yakc_132:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_yakc_133
	ALIGN	2
YKQCreate:
	jmp	L_yakc_153
L_yakc_154:
	call	YKEnterMutex
	mov	word [bp-2], 0
	jmp	L_yakc_156
L_yakc_155:
	inc	word [bp-2]
L_yakc_156:
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQueueArray
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_155
L_yakc_157:
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQueueArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 6
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
	mov	si, ax
	add	si, 8
	mov	word [si], 0
	mov	ax, word [bp-2]
	mov	cx, 10
	imul	cx
	add	ax, YKQueueArray
L_yakc_158:
	mov	sp, bp
	pop	bp
	ret
L_yakc_153:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_154
L_yakc_162:
	DB	"Hey! We got something off a queue!",0xA,0
L_yakc_161:
	DB	"removing ourselves from the queue: ",0
L_yakc_160:
	DB	"pending on queue ",0
	ALIGN	2
YKQPend:
	jmp	L_yakc_163
L_yakc_164:
	call	YKEnterMutex
	push	word [bp+4]
	call	printQueue
	add	sp, 2
	mov	ax, L_yakc_160
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+4]
	call	printInt
	add	sp, 2
	mov	ax, (L_yakc_32+33)
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_165
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKRdyList], ax
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [YKQueueWaitingList]
	mov	word [si], ax
	mov	ax, word [bp-2]
	mov	word [YKQueueWaitingList], ax
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_166
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_166:
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [bp+4]
	mov	word [si], ax
	mov	ax, L_yakc_161
	push	ax
	call	printString
	add	sp, 2
	push	word [bp-2]
	call	printInt
	add	sp, 2
	mov	ax, (L_yakc_32+33)
	push	ax
	call	printString
	add	sp, 2
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_165:
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	shl	ax, 1
	mov	si, ax
	mov	di, word [bp+4]
	add	si, word [di]
	mov	ax, word [si]
	mov	word [bp-4], ax
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	dec	ax
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	inc	ax
	mov	si, word [bp+4]
	add	si, 2
	mov	dx, word [si]
	cmp	dx, ax
	jle	L_yakc_167
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	inc	ax
	jmp	L_yakc_168
L_yakc_167:
	xor	ax, ax
L_yakc_168:
	mov	si, word [bp+4]
	add	si, 4
	mov	word [si], ax
	mov	ax, L_yakc_162
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+4]
	call	printQueue
	add	sp, 2
	call	YKExitMutex
	mov	ax, word [bp-4]
L_yakc_169:
	mov	sp, bp
	pop	bp
	ret
L_yakc_163:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_164
L_yakc_175:
	DB	"just unlocked task ",0
L_yakc_174:
	DB	"think the queue is full?",0xA,0
L_yakc_173:
	DB	" count ",0
L_yakc_172:
	DB	" message ",0
L_yakc_171:
	DB	"posting on queue ",0
	ALIGN	2
YKQPost:
	jmp	L_yakc_176
L_yakc_177:
	call	YKEnterMutex
	mov	ax, L_yakc_171
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+4]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_172
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+6]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_173
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 8
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, (L_yakc_32+33)
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	dec	ax
	mov	si, word [bp+4]
	add	si, 8
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_178
	mov	ax, L_yakc_174
	push	ax
	call	printString
	add	sp, 2
	xor	ax, ax
	jmp	L_yakc_179
L_yakc_178:
	mov	word [bp-4], 0
	mov	ax, word [YKQueueWaitingList]
	mov	word [bp-2], ax
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	shl	ax, 1
	mov	si, ax
	mov	di, word [bp+4]
	add	si, word [di]
	mov	ax, word [bp+6]
	mov	word [si], ax
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	inc	ax
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	inc	ax
	mov	si, word [bp+4]
	add	si, 2
	mov	dx, word [si]
	cmp	dx, ax
	jle	L_yakc_180
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	inc	ax
	jmp	L_yakc_181
L_yakc_180:
	xor	ax, ax
L_yakc_181:
	mov	si, word [bp+4]
	add	si, 6
	mov	word [si], ax
	jmp	L_yakc_183
L_yakc_182:
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_185
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_yakc_186
	mov	ax, word [bp-2]
	mov	word [bp-4], ax
	jmp	L_yakc_187
L_yakc_186:
	mov	si, word [bp-2]
	add	si, 6
	mov	di, word [bp-4]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jle	L_yakc_188
	mov	ax, word [bp-2]
	mov	word [bp-4], ax
L_yakc_188:
L_yakc_187:
L_yakc_185:
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_183:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_182
L_yakc_184:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_yakc_189
	call	YKExitMutex
	mov	ax, 1
	jmp	L_yakc_179
L_yakc_189:
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_190
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKQueueWaitingList], ax
	jmp	L_yakc_191
L_yakc_190:
	mov	si, word [bp-4]
	add	si, 10
	mov	di, word [bp-4]
	add	di, 12
	mov	di, word [di]
	add	di, 10
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_191:
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_192
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-4]
	add	di, 10
	mov	di, word [di]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_192:
	mov	ax, word [YKRdyList]
	mov	word [bp-6], ax
	jmp	L_yakc_194
L_yakc_193:
	mov	si, word [bp-6]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-6], ax
L_yakc_194:
	mov	si, word [bp-6]
	add	si, 6
	mov	di, word [bp-4]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_193
L_yakc_195:
	mov	si, word [bp-6]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_196
	mov	ax, word [bp-4]
	mov	word [YKRdyList], ax
	jmp	L_yakc_197
L_yakc_196:
	mov	si, word [bp-6]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
L_yakc_197:
	mov	si, word [bp-6]
	add	si, 12
	mov	di, word [bp-4]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [bp-6]
	mov	word [si], ax
	mov	si, word [bp-6]
	add	si, 12
	mov	ax, word [bp-4]
	mov	word [si], ax
	mov	si, word [bp-4]
	add	si, 16
	mov	word [si], 0
	mov	ax, L_yakc_175
	push	ax
	call	printString
	add	sp, 2
	push	word [bp-4]
	call	printInt
	add	sp, 2
	mov	ax, (L_yakc_32+33)
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+4]
	call	printQueue
	add	sp, 2
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_198
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_198:
	call	YKExitMutex
	mov	ax, 1
L_yakc_179:
	mov	sp, bp
	pop	bp
	ret
L_yakc_176:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_yakc_177
L_yakc_205:
	DB	0xA,0x9,"count= ",0
L_yakc_204:
	DB	0xA,0x9,"next_slot= ",0
L_yakc_203:
	DB	0xA,0x9,"oldest= ",0
L_yakc_202:
	DB	0xA,0x9,"length= ",0
L_yakc_201:
	DB	0xA,0x9,"base = ",0
L_yakc_200:
	DB	"printing queue ",0
	ALIGN	2
printQueue:
	jmp	L_yakc_206
L_yakc_207:
	call	YKEnterMutex
	mov	ax, L_yakc_200
	push	ax
	call	printString
	add	sp, 2
	push	word [bp+4]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_201
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_202
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 2
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_203
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 4
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_204
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 6
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_yakc_205
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp+4]
	add	si, 8
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, (L_yakc_32+33)
	push	ax
	call	printString
	add	sp, 2
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_206:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_207
	ALIGN	2
YKCtxSwCount:
	TIMES	2 db 0
YKIdleCount:
	TIMES	2 db 0
YKTickNum:
	TIMES	2 db 0
YKRdyList:
	TIMES	2 db 0
YKSuspList:
	TIMES	2 db 0
YKSemaphoreWaitingList:
	TIMES	2 db 0
YKAvailTCBList:
	TIMES	2 db 0
YKTCBArray:
	TIMES	240 db 0
idleStack:
	TIMES	512 db 0
YKISRCallDepth:
	TIMES	2 db 0
YKSEMArray:
	TIMES	76 db 0
YKQueueArray:
	TIMES	20 db 0
YKEVENTArray:
	TIMES	8 db 0
YKQueueWaitingList:
	TIMES	2 db 0
YKEventBlockingList:
	TIMES	2 db 0
YKCurrentlyExecuting:
	TIMES	2 db 0
; All kernel routines that are written in assembly are here 

; Disables interrupts 
YKEnterMutex:
	cli	; clear interrupt flag to disable interrupts 
	ret

; Enables Interrupts 
YKExitMutex:
	sti	; set interrupt flag to enable interrupts 
	ret

YKDispatcher:
	; So if we are following andy's design
	; we will save context here (if the boolean
	; passed to us tells us to)
	
	; Hmm. Should the proper SS and SP be passed to us as an argument?
	; Or shall we fetch them ourselves?


	; I am TRYING to move what YKRdyList is pointing at into the stack pointer
	; Because what YKRdyList points at is the stack pointer of the most ready task
	; Incorrect. The value from the dereferenced YKRdyList needs to be 
	; dereferenced again to get the proper stack pointer
	;mov SP, [YKRdyList]
	mov BX, [YKRdyList]
	mov SP, word [BX]

	; but in any case we need to restore context
	pop ES
	pop DS
	pop DI
	pop SI
	pop BP
	pop DX
	pop CX
	pop BX
	pop AX
	; After this- done by reti
	; IP
	; CS
	; flags
	iret

; This dispatcher has a bool parameter for whether it needs to save context
; @ param: int should_save_context
; @ param: int * save_sp_location
; @ param: int * save_ss_location
; @ param: int * restore_sp_location
; @ param: int * restore_ss_location
YKDispatcher_save_context:
cli
	; Here is where we will deal with our parameters
	push bp
	mov bp, sp
; NOTE: WE DO NOT NEED TO SAVE AX. BECAUSE IT IS THE RETURN REGISTER.

;	push ax				; gotta save ax
	mov ax, word [bp+4]			; getting the bool
	test ax, ax					; if (ax == 0)
;	pop ax				; shouldn't mess up flags
	jz	restoring_context		; If zero, we do NOT store context
storing_context:
	mov AX, [bp+2]	; The return address.
	pop bp
	add sp, 2
	
	pushf
	push CS

;	mov AX, ending_dispatcher
;	push AX
;;	mov AX, [SP+4]	; return address now stored at sp+4
	push AX

	push AX
	push BX
	push CX
	push DX
	push BP						; Maybe not?
	push SI
	push DI
	push DS
	push ES

	mov bp, sp
	add bp, 20

	; Now we just need to store SS and SP in the proper TCB. (these are parameters)
	; 2nd argument, int * save_sp = [bp+6]
	mov si, word [bp+6]
	mov word [si], sp
;	mov word [bp+6], SP
	; 3rd argument, int * save_ss = [bp+8]
	mov si, word [bp+8]
	mov word [si], ss
;	mov word [bp+8], SS


	mov ss, word[bp+12]
	mov sp, word[bp+10]
	jmp real_restoring_context
	
restoring_context:
;	sp is still pointing at the return address.

	; Now we just need to restore SS and SP from the proper TCB. (parameters)
	; 5th argument, int * restore_ss = [bp+12]
	; 4th argument, int * restore_sp = [bp+10]
	mov ss, word[bp+12]
	mov sp, word[bp+10]

real_restoring_context:
	pop ES
	pop DS
	pop DI
	pop SI
	pop BP
	pop DX
	pop CX
	pop BX
	pop AX
	iret			; restores CS, IP, and flags. Starts execution at ENDING_IP

;;;ending_dispatcher:
	; do all the ending crap of the function
;;;	mov sp, bp
;;;	pop bp
;;;	ret				; Takes us back to the scheduler, and context is restored!

;
; POSSIBLE SOLUITION
; Use assembly macro to
; in-line all of this
; so it doesn't have to 
; be a function call
;
;
; (Start stack)
;	IP of task
;	return address
;	[SP points here]
; 
; (End stack)
;	flags
;	CS
;	IP
;	return address
;	[SP points here]
;
;YKSaveFlagsAndCS:
;	sub SP, 4
;	push DX			; Save DX
;	push CX			; Save CX
;	mov DX, SP+12	; DX = IP (to original task)
;	mov CX, SP+10	; CX = return address (to whomever called me)
;	mov SP+8, DX
;	mov SP+6, CX
;	pop CX			; Restore CX
;	pop DX			; Restore DX
;
;	add SP, 8
;	pushf			; push flags into their proper spot
;	push CS			; push CS into its proper spot
;	sub SP, 4
;	
;	jmp YKSaveContext	; Now we are ready to save the rest of context

; This saves the context on the current stack frame 
; We are assuming this is called from an interrupt
;	(if it is not, call YKSaveFlagsAndCS instead)
; So we already have flags, CS, and IP saved properly
;YKSaveContext:
;	;SP + 2 (I think) is return address.
;	sub SP, 18	; Get ready to save 9 words onto the stack
;	push DX
;	mov DX, SP + 22	; mov the return address onto SP 
;	mov SP+4, DX	; put it at the end of the stack, ready to be popped
;	pop DX
;	
;	mov [SP+20], AX
;	mov SP+18, BX
;	mov SP+16, CX
;	mov SP+14, DX
;	mov SP+12, BP
;	mov SP+10, SI
;	mov SP+8, DI
;	mov SP+6, DS
;	mov SP+4, ES
;;	; Current stack: return address, empty 
;;	push AX	; Each 
;	push BX	; one  
;	push CX	; is  
;	push DX	; sp-2 
;	; Instruction Pointer - In interrupt, saved already
;	; Stack pointer - Need to be saved seperately
;	push BP ; Base pointer 
;	push SI ; Source index 
;	push DI ; Destination index    
;	; Code segment - Saved with IP?
;	; Stack segment - saved with SP?
;	push DS ; Data segment 
;	push ES ; Extra segment 
;	; Flags - interrupts already save it
;	ret

; This restores the context FROM the current stack frame 
;YKRestoreContext:
;	mov AX, SP+20
;	mov BX, SP+18
;	mov CX, SP+16
;	mov DX, SP+14
;	mov BP, SP+12
;	mov SI, SP+10
;	mov DI, SP+8
;	mov DS, SP+6
;	mov ES, SP+4
;
;	push DX
;	mov DX, SP+4
;	mov SP+22 , DX
;	pop DX
;	add SP, 18
;	ret

;	add SP, 2	; This deletes the return address saved when we call'ed YKRestoreContext.
;	pop ES
;	pop DS
;	SS
;	CS
;	pop DI
;	pop SI
;	pop BP
;	SP
;	IP

;	pop DX
;	pop CX
;	pop BX
;	pop AX
;	reti		; This pops IP, CS, and the flags, and goes to the return address.

; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
getMovePieceQueueArrayIndex:
	jmp	L_lab8app_1
L_lab8app_2:
	cmp	word [movePieceArrayIndex], 40
	jne	L_lab8app_3
	mov	word [movePieceArrayIndex], 0
L_lab8app_3:
	mov	ax, word [movePieceArrayIndex]
	inc	word [movePieceArrayIndex]
L_lab8app_4:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_1:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_2
	ALIGN	2
getLowerBucket:
	jmp	L_lab8app_6
L_lab8app_7:
	mov	word [bp-2], 0
	mov	word [bp-4], 0
	mov	ax, word [screen0]
	mov	word [bp-6], ax
	mov	ax, word [screen3]
	mov	word [bp-8], ax
	jmp	L_lab8app_9
L_lab8app_8:
	mov	ax, word [bp-2]
	inc	ax
	mov	word [bp-2], ax
	mov	ax, word [bp-6]
	shl	ax, 1
	mov	word [bp-6], ax
L_lab8app_9:
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_lab8app_8
L_lab8app_10:
	jmp	L_lab8app_12
L_lab8app_11:
	mov	ax, word [bp-4]
	inc	ax
	mov	word [bp-4], ax
	mov	ax, word [bp-8]
	shl	ax, 1
	mov	word [bp-8], ax
L_lab8app_12:
	mov	ax, word [bp-8]
	test	ax, ax
	jne	L_lab8app_11
L_lab8app_13:
	mov	ax, word [bp-2]
	cmp	ax, word [bp-4]
	jl	L_lab8app_14
	xor	ax, ax
	jmp	L_lab8app_15
L_lab8app_14:
	mov	ax, 1
L_lab8app_15:
L_lab8app_16:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_6:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_7
	ALIGN	2
isBucketFlat:
	jmp	L_lab8app_18
L_lab8app_19:
	mov	ax, word [bp+4]
	test	ax, ax
	je	L_lab8app_20
	mov	ax, word [screen3]
	mov	word [bp-2], ax
	mov	ax, word [screen5]
	mov	word [bp-4], ax
	jmp	L_lab8app_21
L_lab8app_20:
	mov	ax, word [screen0]
	mov	word [bp-2], ax
	mov	ax, word [screen2]
	mov	word [bp-4], ax
L_lab8app_21:
	jmp	L_lab8app_23
L_lab8app_22:
	mov	ax, word [bp-2]
	shl	ax, 1
	mov	ax, word [bp-4]
	shl	ax, 1
L_lab8app_23:
	mov	ax, word [bp-2]
	test	ax, ax
	je	L_lab8app_25
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_lab8app_22
L_lab8app_25:
L_lab8app_24:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	je	L_lab8app_26
	xor	ax, ax
	jmp	L_lab8app_27
L_lab8app_26:
	mov	ax, 1
L_lab8app_27:
L_lab8app_28:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_18:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab8app_19
L_lab8app_30:
	DB	"You really want a column not 0-5???",0xA,0
	ALIGN	2
getLowestSpace:
	jmp	L_lab8app_31
L_lab8app_32:
	mov	word [bp-2], 0
	mov	ax, word [bp+4]
	sub	ax, 0
	je	L_lab8app_35
	dec	ax
	je	L_lab8app_36
	dec	ax
	je	L_lab8app_37
	dec	ax
	je	L_lab8app_38
	dec	ax
	je	L_lab8app_39
	dec	ax
	je	L_lab8app_40
	jmp	L_lab8app_34
L_lab8app_35:
	mov	ax, word [screen0]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_36:
	mov	ax, word [screen1]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_37:
	mov	ax, word [screen2]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_38:
	mov	ax, word [screen3]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_39:
	mov	ax, word [screen4]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_40:
	mov	ax, word [screen5]
	mov	word [bp-4], ax
	jmp	L_lab8app_33
L_lab8app_34:
	mov	ax, L_lab8app_30
	push	ax
	call	printString
	add	sp, 2
L_lab8app_33:
	jmp	L_lab8app_42
L_lab8app_41:
	mov	ax, word [bp-2]
	inc	ax
	mov	word [bp-2], ax
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	word [bp-4], ax
L_lab8app_42:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_lab8app_41
L_lab8app_43:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_31:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab8app_32
L_lab8app_45:
	DB	"CODE NOT WRITTEN :'(",0
	ALIGN	2
tryToClearLine:
	jmp	L_lab8app_46
L_lab8app_47:
	mov	ax, 1
	mov	cx, word [bp+4]
	shl	ax, cl
	and	ax, word [screen0]
	je	L_lab8app_48
	mov	ax, 1
	shl	ax, cl
	and	ax, word [screen1]
	je	L_lab8app_48
	mov	ax, 1
	shl	ax, cl
	and	ax, word [screen2]
	je	L_lab8app_48
	mov	ax, 1
	shl	ax, cl
	and	ax, word [screen3]
	je	L_lab8app_48
	mov	ax, 1
	shl	ax, cl
	and	ax, word [screen4]
	je	L_lab8app_48
	mov	ax, 1
	shl	ax, cl
	and	ax, word [screen5]
	je	L_lab8app_48
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_lab8app_49
	mov	ax, word [screen0]
	shl	ax, 1
	mov	word [screen0], ax
	mov	ax, word [screen1]
	shl	ax, 1
	mov	word [screen1], ax
	mov	ax, word [screen2]
	shl	ax, 1
	mov	word [screen2], ax
	mov	ax, word [screen3]
	shl	ax, 1
	mov	word [screen3], ax
	mov	ax, word [screen4]
	shl	ax, 1
	mov	word [screen4], ax
	mov	ax, word [screen5]
	shl	ax, 1
	mov	word [screen5], ax
	jmp	L_lab8app_50
L_lab8app_49:
	mov	ax, L_lab8app_45
	push	ax
	call	printString
	add	sp, 2
L_lab8app_50:
L_lab8app_48:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_46:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_47
L_lab8app_62:
	DB	"Thank you for playing newPieceTask. The while loop will now cycle to the beginning",0xA,0
L_lab8app_61:
	DB	"oops. it is a corner piece",0xA,0
L_lab8app_60:
	DB	"rotating straight piece",0xA,0
L_lab8app_59:
	DB	"moving straight piece left",0xA,0
L_lab8app_58:
	DB	"Moving Straight piece right",0xA,0
L_lab8app_57:
	DB	"Straight piece received!",0xA,0
L_lab8app_56:
	DB	0xA,"column: ",0
L_lab8app_55:
	DB	0xA,"orientation: ",0
L_lab8app_54:
	DB	0xA,"type: ",0
L_lab8app_53:
	DB	"received a message!",0xA,"ID: ",0
L_lab8app_52:
	DB	"newPieceTask moving!",0xA,0
	ALIGN	2
newPieceTask:
	jmp	L_lab8app_63
L_lab8app_64:
	mov	ax, L_lab8app_52
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_66
L_lab8app_65:
	push	word [newPieceQueuePTR]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	mov	ax, L_lab8app_53
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_lab8app_54
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_lab8app_55
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, L_lab8app_56
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	add	si, 6
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, (L_lab8app_30+35)
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	add	si, 2
	cmp	word [si], 1
	jne	L_lab8app_68
	mov	ax, L_lab8app_57
	push	ax
	call	printString
	add	sp, 2
	call	getLowerBucket
	mov	word [bp-4], ax
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	mov	word [bp-6], ax
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_69
	mov	ax, 3
	jmp	L_lab8app_70
L_lab8app_69:
	xor	ax, ax
L_lab8app_70:
	push	ax
	call	getLowestSpace
	add	sp, 2
	mov	word [bp-10], ax
	mov	ax, word [bp-4]
	mov	word [bp-12], ax
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_71
	mov	ax, 4
	jmp	L_lab8app_72
L_lab8app_71:
	mov	ax, 1
L_lab8app_72:
	mov	word [bp-4], ax
	jmp	L_lab8app_74
L_lab8app_73:
	mov	ax, L_lab8app_58
	push	ax
	call	printString
	add	sp, 2
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_74:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_73
L_lab8app_75:
	jmp	L_lab8app_77
L_lab8app_76:
	mov	ax, L_lab8app_59
	push	ax
	call	printString
	add	sp, 2
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_77:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jl	L_lab8app_76
L_lab8app_78:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_79
	mov	ax, L_lab8app_60
	push	ax
	call	printString
	add	sp, 2
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_79:
	mov	ax, word [bp-12]
	test	ax, ax
	jne	L_lab8app_80
	mov	ax, 1
	mov	cx, word [bp-10]
	shl	ax, cl
	or	ax, word [screen0]
	mov	word [screen0], ax
	mov	ax, 1
	shl	ax, cl
	or	ax, word [screen1]
	mov	word [screen1], ax
	mov	ax, 1
	shl	ax, cl
	or	ax, word [screen2]
	mov	word [screen2], ax
L_lab8app_80:
	push	word [bp-10]
	call	tryToClearLine
	add	sp, 2
	jmp	L_lab8app_81
L_lab8app_68:
	mov	ax, L_lab8app_61
	push	ax
	call	printString
	add	sp, 2
	call	getLowerBucket
	mov	word [bp-4], ax
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	mov	word [bp-6], ax
	push	word [bp-4]
	call	isBucketFlat
	add	sp, 2
	test	ax, ax
	je	L_lab8app_82
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_84
	xor	ax, ax
	jmp	L_lab8app_85
L_lab8app_84:
	mov	ax, 1
L_lab8app_85:
	push	ax
	call	isBucketFlat
	add	sp, 2
	test	ax, ax
	je	L_lab8app_83
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_86
	mov	word [bp-4], 3
	jmp	L_lab8app_88
L_lab8app_87:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_88:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_87
L_lab8app_89:
	jmp	L_lab8app_91
L_lab8app_90:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_91:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jl	L_lab8app_90
L_lab8app_92:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_93
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_93:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	jne	L_lab8app_94
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_94:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_96
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_95
L_lab8app_96:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_95:
	jmp	L_lab8app_97
L_lab8app_86:
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_lab8app_98
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_98
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
	jmp	L_lab8app_99
L_lab8app_98:
	cmp	word [bp-6], 5
	jne	L_lab8app_100
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_100
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_100:
L_lab8app_99:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_101
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_101:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	jne	L_lab8app_102
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_102:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_104
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_103
L_lab8app_104:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_103:
	jmp	L_lab8app_106
L_lab8app_105:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_106:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jl	L_lab8app_105
L_lab8app_107:
L_lab8app_97:
	jmp	L_lab8app_108
L_lab8app_83:
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_109
	xor	ax, ax
	jmp	L_lab8app_110
L_lab8app_109:
	mov	ax, 1
L_lab8app_110:
	mov	word [bp-4], ax
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_111
	mov	ax, 5
	jmp	L_lab8app_112
L_lab8app_111:
	mov	ax, 2
L_lab8app_112:
	mov	word [bp-4], ax
	cmp	word [bp-4], 5
	jne	L_lab8app_113
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_lab8app_114
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_114
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
	jmp	L_lab8app_115
L_lab8app_114:
	cmp	word [bp-6], 5
	jne	L_lab8app_116
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_116
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_116:
L_lab8app_115:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_117
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_117:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_118
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_118:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_120
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_119
L_lab8app_120:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_119:
	jmp	L_lab8app_122
L_lab8app_121:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_122:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_121
L_lab8app_123:
	jmp	L_lab8app_124
L_lab8app_113:
	jmp	L_lab8app_126
L_lab8app_125:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_126:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_125
L_lab8app_127:
	jmp	L_lab8app_129
L_lab8app_128:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_129:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jl	L_lab8app_128
L_lab8app_130:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_131
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_131:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_132
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_132:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_134
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_133
L_lab8app_134:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_133:
L_lab8app_124:
L_lab8app_108:
	jmp	L_lab8app_135
L_lab8app_82:
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_lab8app_136
	mov	ax, 5
	jmp	L_lab8app_137
L_lab8app_136:
	mov	ax, 2
L_lab8app_137:
	mov	word [bp-4], ax
	cmp	word [bp-4], 5
	jne	L_lab8app_138
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_lab8app_139
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_139
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
	jmp	L_lab8app_140
L_lab8app_139:
	cmp	word [bp-6], 5
	jne	L_lab8app_141
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 2
	je	L_lab8app_141
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_141:
L_lab8app_140:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_142
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_142:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_143
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_143:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_145
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_144
L_lab8app_145:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_144:
	jmp	L_lab8app_147
L_lab8app_146:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_147:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_146
L_lab8app_148:
	jmp	L_lab8app_149
L_lab8app_138:
	jmp	L_lab8app_151
L_lab8app_150:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	inc	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_151:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jg	L_lab8app_150
L_lab8app_152:
	jmp	L_lab8app_154
L_lab8app_153:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], SlidePiece
	mov	ax, word [bp-6]
	dec	ax
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_154:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-6]
	jl	L_lab8app_153
L_lab8app_155:
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 1
	jne	L_lab8app_156
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_156:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_157
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_157:
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_159
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jne	L_lab8app_158
L_lab8app_159:
	call	getMovePieceQueueArrayIndex
	mov	word [bp-8], ax
	mov	si, word [bp-2]
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	mov	di, ax
	add	di, movePieceArray
	mov	ax, word [si]
	mov	word [di], ax
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	mov	si, ax
	add	si, 2
	mov	word [si], RotatePiece
	mov	ax, word [bp-8]
	mov	cx, 6
	imul	cx
	add	ax, movePieceArray
	push	ax
	push	word [movePieceQueuePTR]
	call	YKQPost
	add	sp, 4
L_lab8app_158:
L_lab8app_149:
L_lab8app_135:
L_lab8app_81:
	mov	ax, L_lab8app_62
	push	ax
	call	printString
	add	sp, 2
L_lab8app_66:
	jmp	L_lab8app_65
L_lab8app_67:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_63:
	push	bp
	mov	bp, sp
	sub	sp, 12
	jmp	L_lab8app_64
L_lab8app_165:
	DB	"called the function!",0xA,0
L_lab8app_164:
	DB	"got a piece. ID ",0
L_lab8app_163:
	DB	"piece move event. getting move now",0xA,0
L_lab8app_162:
	DB	"Wait for event!",0xA,0
L_lab8app_161:
	DB	"movePieceTask moving!",0xA,0
	ALIGN	2
movePieceTask:
	jmp	L_lab8app_166
L_lab8app_167:
	mov	ax, L_lab8app_161
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_169
L_lab8app_168:
	mov	ax, L_lab8app_162
	push	ax
	call	printString
	add	sp, 2
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [pieceMoveEvent]
	call	YKEventPend
	add	sp, 6
	mov	ax, 1
	push	ax
	push	word [pieceMoveEvent]
	call	YKEventReset
	add	sp, 4
	mov	ax, L_lab8app_163
	push	ax
	call	printString
	add	sp, 2
	push	word [movePieceQueuePTR]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	mov	ax, L_lab8app_164
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	push	word [si]
	call	printInt
	add	sp, 2
	mov	ax, (L_lab8app_30+35)
	push	ax
	call	printString
	add	sp, 2
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	add	si, 2
	mov	si, word [si]
	call	si
	add	sp, 4
	mov	ax, L_lab8app_165
	push	ax
	call	printString
	add	sp, 2
L_lab8app_169:
	jmp	L_lab8app_168
L_lab8app_170:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_166:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_167
L_lab8app_176:
	DB	"% >>>>>",0xD,0xA,0
L_lab8app_175:
	DB	", CPU usage: ",0
L_lab8app_174:
	DB	"<<<<< Context switches: ",0
L_lab8app_173:
	DB	"Determining CPU capacity",0xD,0xA,0
L_lab8app_172:
	DB	"Welcome to the YAK kernel",0xD,0xA,0
	ALIGN	2
STask:
	jmp	L_lab8app_177
L_lab8app_178:
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	mov	ax, L_lab8app_172
	push	ax
	call	printString
	add	sp, 2
	mov	ax, L_lab8app_173
	push	ax
	call	printString
	add	sp, 2
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	mov	word [YKIdleCount], 0
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	mov	ax, word [YKIdleCount]
	xor	dx, dx
	mov	cx, 25
	div	cx
	mov	word [bp-2], ax
	mov	word [YKIdleCount], 0
	mov	ax, 1251
	xor	dx, dx
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	mov	al, 5
	push	ax
	mov	ax, (newPieceTaskStk+1024)
	push	ax
	mov	ax, newPieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	mov	al, 3
	push	ax
	mov	ax, (movePieceTaskStk+1024)
	push	ax
	mov	ax, movePieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	call	StartSimptris
	jmp	L_lab8app_180
L_lab8app_179:
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	call	YKEnterMutex
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	call	YKExitMutex
	mov	ax, L_lab8app_174
	push	ax
	call	printString
	add	sp, 2
	push	word [bp-4]
	call	printInt
	add	sp, 2
	mov	ax, L_lab8app_175
	push	ax
	call	printString
	add	sp, 2
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	mov	ax, L_lab8app_176
	push	ax
	call	printString
	add	sp, 2
	call	YKEnterMutex
	mov	word [YKCtxSwCount], 0
	mov	word [YKIdleCount], 0
	call	YKExitMutex
L_lab8app_180:
	jmp	L_lab8app_179
L_lab8app_181:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_177:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_178
	ALIGN	2
main:
	jmp	L_lab8app_183
L_lab8app_184:
	call	YKInitialize
	mov	ax, 10
	push	ax
	mov	ax, newPieceQueue
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [newPieceQueuePTR], ax
	mov	ax, 20
	push	ax
	mov	ax, movePieceQueue
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [movePieceQueuePTR], ax
	mov	ax, 1
	push	ax
	call	YKEventCreate
	add	sp, 2
	mov	word [pieceMoveEvent], ax
	xor	al, al
	push	ax
	mov	ax, (STaskStk+1024)
	push	ax
	mov	ax, STask
	push	ax
	call	YKNewTask
	add	sp, 6
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_183:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_184
	ALIGN	2
movePieceQueuePTR:
	TIMES	2 db 0
newPieceQueuePTR:
	TIMES	2 db 0
pieceMoveEvent:
	TIMES	2 db 0
STaskStk:
	TIMES	1024 db 0
testintbog:
	TIMES	2 db 0
test2:
	TIMES	2 db 0
movePieceTaskStk:
	TIMES	1024 db 0
test3:
	TIMES	2 db 0
test4:
	TIMES	2 db 0
newPieceTaskStk:
	TIMES	1024 db 0
test5:
	TIMES	2 db 0
test6:
	TIMES	2 db 0
newPieceArray:
	TIMES	160 db 0
newPieceQueue:
	TIMES	20 db 0
movePieceArray:
	TIMES	240 db 0
movePieceArrayIndex:
	TIMES	2 db 0
movePieceQueue:
	TIMES	40 db 0
screen0:
	TIMES	2 db 0
screen1:
	TIMES	2 db 0
screen2:
	TIMES	2 db 0
screen3:
	TIMES	2 db 0
screen4:
	TIMES	2 db 0
screen5:
	TIMES	2 db 0
